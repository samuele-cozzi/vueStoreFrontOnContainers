/*
 * Akeneo PIM API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Catalog.Nosql.Model.Akeneo
{ 
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class ReferenceEntityAttribute : IEquatable<ReferenceEntityAttribute>
    { 
        /// <summary>
        /// Attribute code
        /// </summary>
        /// <value>Attribute code</value>
        [Required]
        [DataMember(Name="code")]
        public string Code { get; set; }

        /// <summary>
        /// Gets or Sets Labels
        /// </summary>
        [DataMember(Name="labels")]
        public Apirestv1attributesLabels Labels { get; set; }

        /// <summary>
        /// Attribute type
        /// </summary>
        /// <value>Attribute type</value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum TypeEnum
        {
            
            /// <summary>
            /// Enum TextEnum for text
            /// </summary>
            [EnumMember(Value = "text")]
            TextEnum = 1,
            
            /// <summary>
            /// Enum ImageEnum for image
            /// </summary>
            [EnumMember(Value = "image")]
            ImageEnum = 2,
            
            /// <summary>
            /// Enum SingleOptionEnum for single_option
            /// </summary>
            [EnumMember(Value = "single_option")]
            SingleOptionEnum = 3,
            
            /// <summary>
            /// Enum MultipleOptionsEnum for multiple_options
            /// </summary>
            [EnumMember(Value = "multiple_options")]
            MultipleOptionsEnum = 4,
            
            /// <summary>
            /// Enum ReferenceEntitySingleLinkEnum for reference_entity_single_link
            /// </summary>
            [EnumMember(Value = "reference_entity_single_link")]
            ReferenceEntitySingleLinkEnum = 5,
            
            /// <summary>
            /// Enum ReferenceEntityMultipleLinksEnum for reference_entity_multiple_links
            /// </summary>
            [EnumMember(Value = "reference_entity_multiple_links")]
            ReferenceEntityMultipleLinksEnum = 6
        }

        /// <summary>
        /// Attribute type
        /// </summary>
        /// <value>Attribute type</value>
        [Required]
        [DataMember(Name="type")]
        public TypeEnum? Type { get; set; }

        /// <summary>
        /// Whether the attribute is localizable, i.e. can have one value by locale
        /// </summary>
        /// <value>Whether the attribute is localizable, i.e. can have one value by locale</value>
        [DataMember(Name="value_per_locale")]
        public bool? ValuePerLocale { get; set; }

        /// <summary>
        /// Whether the attribute is scopable, i.e. can have one value by channel
        /// </summary>
        /// <value>Whether the attribute is scopable, i.e. can have one value by channel</value>
        [DataMember(Name="value_per_channel")]
        public bool? ValuePerChannel { get; set; }

        /// <summary>
        /// Whether the attribute should be part of the record&#39;s completeness calculation
        /// </summary>
        /// <value>Whether the attribute should be part of the record&#39;s completeness calculation</value>
        [DataMember(Name="is_required_for_completeness")]
        public bool? IsRequiredForCompleteness { get; set; }

        /// <summary>
        /// Maximum number of characters allowed for the value of the attribute when the attribute type is &#x60;text&#x60;
        /// </summary>
        /// <value>Maximum number of characters allowed for the value of the attribute when the attribute type is &#x60;text&#x60;</value>
        [DataMember(Name="max_characters")]
        public int? MaxCharacters { get; set; }

        /// <summary>
        /// Whether the UI should display a text area instead of a simple field when the attribute type is &#x60;text&#x60;
        /// </summary>
        /// <value>Whether the UI should display a text area instead of a simple field when the attribute type is &#x60;text&#x60;</value>
        [DataMember(Name="is_textarea")]
        public bool? IsTextarea { get; set; }

        /// <summary>
        /// Whether the UI should display a rich text editor instead of a simple text area when the attribute type is &#x60;text&#x60;
        /// </summary>
        /// <value>Whether the UI should display a rich text editor instead of a simple text area when the attribute type is &#x60;text&#x60;</value>
        [DataMember(Name="is_rich_text_editor")]
        public bool? IsRichTextEditor { get; set; }

        /// <summary>
        /// Validation rule type used to validate the attribute value when the attribute type is `text`
        /// </summary>
        /// <value>Validation rule type used to validate the attribute value when the attribute type is `text`</value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum ValidationRuleEnum
        {
            
            /// <summary>
            /// Enum EmailEnum for email
            /// </summary>
            [EnumMember(Value = "email")]
            EmailEnum = 1,
            
            /// <summary>
            /// Enum UrlEnum for url
            /// </summary>
            [EnumMember(Value = "url")]
            UrlEnum = 2,
            
            /// <summary>
            /// Enum RegexpEnum for regexp
            /// </summary>
            [EnumMember(Value = "regexp")]
            RegexpEnum = 3,
            
            /// <summary>
            /// Enum NoneEnum for none
            /// </summary>
            [EnumMember(Value = "none")]
            NoneEnum = 4
        }

        /// <summary>
        /// Validation rule type used to validate the attribute value when the attribute type is &#x60;text&#x60;
        /// </summary>
        /// <value>Validation rule type used to validate the attribute value when the attribute type is &#x60;text&#x60;</value>
        [DataMember(Name="validation_rule")]
        public ValidationRuleEnum? ValidationRule { get; set; }

        /// <summary>
        /// Regexp expression used to validate the attribute value when the attribute type is &#x60;text&#x60;
        /// </summary>
        /// <value>Regexp expression used to validate the attribute value when the attribute type is &#x60;text&#x60;</value>
        [DataMember(Name="validation_regexp")]
        public string ValidationRegexp { get; set; }

        /// <summary>
        /// Extensions allowed when the attribute type is &#x60;image&#x60;
        /// </summary>
        /// <value>Extensions allowed when the attribute type is &#x60;image&#x60;</value>
        [DataMember(Name="allowed_extensions")]
        public List<string> AllowedExtensions { get; set; }

        /// <summary>
        /// Max file size in MB when the attribute type is &#x60;image&#x60;
        /// </summary>
        /// <value>Max file size in MB when the attribute type is &#x60;image&#x60;</value>
        [DataMember(Name="max_file_size")]
        public string MaxFileSize { get; set; }

        /// <summary>
        /// Code of the linked reference entity when the attribute type is &#x60;reference_entity_single_link&#x60; or &#x60;reference_entity_multiple_links&#x60;
        /// </summary>
        /// <value>Code of the linked reference entity when the attribute type is &#x60;reference_entity_single_link&#x60; or &#x60;reference_entity_multiple_links&#x60;</value>
        [DataMember(Name="reference_entity_code")]
        public string ReferenceEntityCode { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ReferenceEntityAttribute {\n");
            sb.Append("  Code: ").Append(Code).Append("\n");
            sb.Append("  Labels: ").Append(Labels).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  ValuePerLocale: ").Append(ValuePerLocale).Append("\n");
            sb.Append("  ValuePerChannel: ").Append(ValuePerChannel).Append("\n");
            sb.Append("  IsRequiredForCompleteness: ").Append(IsRequiredForCompleteness).Append("\n");
            sb.Append("  MaxCharacters: ").Append(MaxCharacters).Append("\n");
            sb.Append("  IsTextarea: ").Append(IsTextarea).Append("\n");
            sb.Append("  IsRichTextEditor: ").Append(IsRichTextEditor).Append("\n");
            sb.Append("  ValidationRule: ").Append(ValidationRule).Append("\n");
            sb.Append("  ValidationRegexp: ").Append(ValidationRegexp).Append("\n");
            sb.Append("  AllowedExtensions: ").Append(AllowedExtensions).Append("\n");
            sb.Append("  MaxFileSize: ").Append(MaxFileSize).Append("\n");
            sb.Append("  ReferenceEntityCode: ").Append(ReferenceEntityCode).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((ReferenceEntityAttribute)obj);
        }

        /// <summary>
        /// Returns true if ReferenceEntityAttribute instances are equal
        /// </summary>
        /// <param name="other">Instance of ReferenceEntityAttribute to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ReferenceEntityAttribute other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Code == other.Code ||
                    Code != null &&
                    Code.Equals(other.Code)
                ) && 
                (
                    Labels == other.Labels ||
                    Labels != null &&
                    Labels.Equals(other.Labels)
                ) && 
                (
                    Type == other.Type ||
                    Type != null &&
                    Type.Equals(other.Type)
                ) && 
                (
                    ValuePerLocale == other.ValuePerLocale ||
                    ValuePerLocale != null &&
                    ValuePerLocale.Equals(other.ValuePerLocale)
                ) && 
                (
                    ValuePerChannel == other.ValuePerChannel ||
                    ValuePerChannel != null &&
                    ValuePerChannel.Equals(other.ValuePerChannel)
                ) && 
                (
                    IsRequiredForCompleteness == other.IsRequiredForCompleteness ||
                    IsRequiredForCompleteness != null &&
                    IsRequiredForCompleteness.Equals(other.IsRequiredForCompleteness)
                ) && 
                (
                    MaxCharacters == other.MaxCharacters ||
                    MaxCharacters != null &&
                    MaxCharacters.Equals(other.MaxCharacters)
                ) && 
                (
                    IsTextarea == other.IsTextarea ||
                    IsTextarea != null &&
                    IsTextarea.Equals(other.IsTextarea)
                ) && 
                (
                    IsRichTextEditor == other.IsRichTextEditor ||
                    IsRichTextEditor != null &&
                    IsRichTextEditor.Equals(other.IsRichTextEditor)
                ) && 
                (
                    ValidationRule == other.ValidationRule ||
                    ValidationRule != null &&
                    ValidationRule.Equals(other.ValidationRule)
                ) && 
                (
                    ValidationRegexp == other.ValidationRegexp ||
                    ValidationRegexp != null &&
                    ValidationRegexp.Equals(other.ValidationRegexp)
                ) && 
                (
                    AllowedExtensions == other.AllowedExtensions ||
                    AllowedExtensions != null &&
                    AllowedExtensions.SequenceEqual(other.AllowedExtensions)
                ) && 
                (
                    MaxFileSize == other.MaxFileSize ||
                    MaxFileSize != null &&
                    MaxFileSize.Equals(other.MaxFileSize)
                ) && 
                (
                    ReferenceEntityCode == other.ReferenceEntityCode ||
                    ReferenceEntityCode != null &&
                    ReferenceEntityCode.Equals(other.ReferenceEntityCode)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Code != null)
                    hashCode = hashCode * 59 + Code.GetHashCode();
                    if (Labels != null)
                    hashCode = hashCode * 59 + Labels.GetHashCode();
                    if (Type != null)
                    hashCode = hashCode * 59 + Type.GetHashCode();
                    if (ValuePerLocale != null)
                    hashCode = hashCode * 59 + ValuePerLocale.GetHashCode();
                    if (ValuePerChannel != null)
                    hashCode = hashCode * 59 + ValuePerChannel.GetHashCode();
                    if (IsRequiredForCompleteness != null)
                    hashCode = hashCode * 59 + IsRequiredForCompleteness.GetHashCode();
                    if (MaxCharacters != null)
                    hashCode = hashCode * 59 + MaxCharacters.GetHashCode();
                    if (IsTextarea != null)
                    hashCode = hashCode * 59 + IsTextarea.GetHashCode();
                    if (IsRichTextEditor != null)
                    hashCode = hashCode * 59 + IsRichTextEditor.GetHashCode();
                    if (ValidationRule != null)
                    hashCode = hashCode * 59 + ValidationRule.GetHashCode();
                    if (ValidationRegexp != null)
                    hashCode = hashCode * 59 + ValidationRegexp.GetHashCode();
                    if (AllowedExtensions != null)
                    hashCode = hashCode * 59 + AllowedExtensions.GetHashCode();
                    if (MaxFileSize != null)
                    hashCode = hashCode * 59 + MaxFileSize.GetHashCode();
                    if (ReferenceEntityCode != null)
                    hashCode = hashCode * 59 + ReferenceEntityCode.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(ReferenceEntityAttribute left, ReferenceEntityAttribute right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(ReferenceEntityAttribute left, ReferenceEntityAttribute right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
